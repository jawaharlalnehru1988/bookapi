{"Angular": [
    {
      "id":9,
      "title": "Angular Form",
      "intro": "<p>In Angular, forms are used to collect user input and submit it to a server for further processing. Forms can be created using either Template-Driven Forms or Reactive Forms.</p> <p>Template-Driven Forms are built using Angular's built-in ngModel directive, which allows two-way data binding between the form controls and the component's properties. Template-Driven Forms are simpler and faster to set up, but can be less flexible and harder to maintain in complex forms.</p> <p>Reactive Forms, on the other hand, are built using the ReactiveFormsModule module, which provides a more powerful and flexible way of building forms. Reactive Forms allow you to create and manipulate form controls programmatically and provide better support for complex scenarios such as conditional validation and dynamic forms.</p>",
      "subtopic": [
        {
          "title": "Creating a form group",
          "description": "Learn how to create a FormGroup object to represent a group of form controls in your Angular reactive form.",
          "example": "import { NgModule } from '@angular/core'; \n import { FormsModule } from '@angular/forms'; \n @NgModule({ \n imports: [ \n FormsModule ], // ... }) \n export class AppModule { }"
        },
        {
          "title": "Creating form controls",
          "description": "Learn how to create FormControl objects to represent individual form controls in your Angular reactive form."
        },
        {
          "title": "Adding form validation",
          "description": "Learn how to add form validation rules to your Angular reactive form, such as required fields, minimum and maximum values, and custom validation functions."
        },
        {
          "title": "Reactive form data binding",
          "description": "Learn how to bind your reactive form to your component data model using two-way data binding or reactive programming techniques."
        },
        {
          "title": "Dynamic form controls",
          "description": "Learn how to dynamically add or remove form controls based on user input or other dynamic factors in your Angular reactive form."
        },
        {
          "title": "Form arrays",
          "description": "Learn how to use FormArray objects to represent an array of form controls in your Angular reactive form."
        },
        {
          "title": "Form groups nesting",
          "description": "Learn how to nest FormGroup and FormArray objects to create complex forms with hierarchical data structures in your Angular reactive form."
        },
        {
          "title": "Form control value changes",
          "description": "Learn how to detect and respond to changes in form control values, such as using the valueChanges property and reactive programming techniques in your Angular reactive form."
        },
        {
          "title": "Form submission",
          "description": "Learn how to handle form submission in your Angular reactive form, such as preventing default form submission behavior, sending form data to a server, and displaying success or error messages."
        }
      ]
    },
    {
      "id":24,
      "title":"lifeCycleHookList",
      "intro":"",
      "subtopic": [
        {
          "name": "ngOnChanges",
          "description": "Called when one or more input properties change.",
          "usage": "@Input() myProperty: string; \nngOnChanges(changes: SimpleChanges) { \n  console.log('Changes:', changes); \n}"
        },
        {
          "name": "ngOnInit",
          "description": "Called once the component has been initialized.",
          "usage": "ngOnInit() { \n  console.log('Component initialized'); \n}"
        },
        {
          "name": "ngDoCheck",
          "description": "Called during every change detection cycle.",
          "usage": "ngDoCheck() { \n  console.log('Change detection executed'); \n}"
        },
        {
          "name": "ngAfterContentInit",
          "description": "Called once content has been projected into the component.",
          "usage": "ngAfterContentInit() { \n  console.log('Content initialized'); \n}"
        },
        {
          "name": "ngAfterContentChecked",
          "description": "Called during every change detection cycle after projecting content into the component.",
          "usage": "ngAfterContentChecked() { \n  console.log('Content checked'); \n}"
        },
        {
          "name": "ngAfterViewInit",
          "description": "Called once the component's view has been initialized.",
          "usage": "ngAfterViewInit() { \n  console.log('View initialized'); \n}"
        },
        {
          "name": "ngAfterViewChecked",
          "description": "Called during every change detection cycle after initializing the component's view.",
          "usage": "ngAfterViewChecked() { \n  console.log('View checked'); \n}"
        },
        {
          "name": "ngOnDestroy",
          "description": "Called just before the component is destroyed.",
          "usage": "ngOnDestroy() { \n  console.log('Component destroyed'); \n}"
        }
      ]
    }
  ]
}